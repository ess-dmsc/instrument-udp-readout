DEFINE COMPONENT Event_broadcaster
DEFINITION PARAMETERS()
SETTING PARAMETERS (
string ring = 0,
string fen = 0,
string tube = 0,
string a = 0,
string b = 0,
string tof = "t",
string ip = 0,
int port = 9000,
int broadcast = 1,
pulse_rate = 14
)
OUTPUT PARAMETERS ()
DEPENDENCY "-I src -L. -lwrapper"
SHARE
%{
#include <sys/time.h>
#include <stdlib.h>
#include <stdint.h>
#include <wrapper.h>

#include <unistd.h>

  struct efu_time {
    uint32_t hi;
    uint32_t lo;
  };
  typedef struct efu_time efu_time_t;

  void throw_error(char* named, char* variable){
    printf("Event_broadcaster: %s: Particle variable %s inaccessible, exiting.\n", named, variable);
    exit(-1);
  }

  int particle_getvar_int(_class_particle* p, char* name){
      double bits = particle_getvar(p, name, 0);
      return *(int*)&bits;
  }

%}

DECLARE
%{
// pre-declare the stateful object
miracles_readout_t* miracles;
efu_time_t last_time;
efu_time_t repetition_time;
efu_time_t offset_time;
efu_time_t now_time;
%}

INITIALIZE
%{
  // Include the header file and run any initialization for the real broadcaster
  if (ip == 0 || ip[0] == '\0'){
  	miracles = miracles_readout_create("127.0.0.1", port);
  } else {
  	miracles = miracles_readout_create(ip, port);
  }

  miracles_readout_setPulseTime(miracles, 0, 0, 0, 0);
  miracles_readout_newPacket(miracles);

%}

TRACE
%{
  if (broadcast){
	  // TODO combine these three into a single 'flush' call?
	  miracles_readout_send(miracles);
		miracles_readout_newPacket(miracles);
	  miracles_readout_setPulseTime(miracles, 0, 0, 0, 0);
	}

  uint8_t RING;
  uint8_t FEN;
  uint8_t tube_pair;
  uint16_t A;
  uint16_t B;

// Send the event to the broadcaster to be accumulated and broadcast
  if (broadcast) {
    // First calculate angle theta, then calculate the tube in ICD nomenclature
    // where tubes increase clockwise
    double r = sqrt(z*z + x*x);
    double theta = acos(1.0*z/r);
    int hetube = 47 - theta*47/3.1415926;

    // Rings depend on hetube # and y-position (four quadrants)
    if (hetube > 23) {
      if (y >= 0) {
        RING = 1;
      } else {
        RING = 3;
      }
    } else {
      if (y >= 0) {
        RING = 0;
      } else {
        RING = 2;
      }
    }

    FEN = 0; // always for MIRACLES

    tube_pair = (hetube/2)%11;

    // Amplitudes are dependent on 'A' or 'B' end of a tube-pair and y value
    A = 5000;
    B = 5000;

    double pos;
    pos = 1.0 - (fabs(y)/0.150);
    if (pos <= 0.5) {
      B = 5000;
      A = B * pos / (1 - pos);
    } else {
      A = 5000;
      B = A *(1-pos)/pos;
    }

    //printf("\n NEUTRON at theta %f, hetube %u, tube_pair %u (x,y,z %f %f %f), t %.0f(us)\n", theta, hetube, tube_pair, x, y, z, t*1000000);
    printf(" READOUT - RING %2u FEN %2u TUBE %2u (hetube %2u) - A %5u B %5u TOF %10u(ns)\n", \
           RING, FEN, tube_pair, hetube, A, B, (int)(t * 1000000000));
    miracles_readout_add(miracles, 2 * RING, FEN, 0, (int)(t * 1000000000), tube_pair, A, B);
  }
%}

FINALLY
%{
  // perform any teardown of the stateful broadcaster
  if (broadcast) miracles_readout_send(miracles);
    miracles_readout_destroy(miracles);
%}

MCDISPLAY
%{
%}

END
